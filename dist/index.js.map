{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["import { ReturnFetchJsonDefaultOptions } from '../packages/return-fetch-json/src/index';\n/**\n * A simple and powerful high order function to extend fetch.\n *\n * @packageDocumentation\n */\n\n/**\n * Arguments of fetch function.\n *\n * @throws {Error} if a first argument of fetch is `Request` object. only string and URL are supported.\n * @see {fetch, RequestInfo, Request}\n *\n * @public\n */\nexport type FetchArgs = [string | URL, RequestInit | undefined];\n\n/**\n * Type of `returnFetch` function.\n * It is useful for whom want to write customized returnFetch function.\n *\n * @public\n */\nexport type ReturnFetch = typeof returnFetch;\n\n/**\n * Options of `returnFetch` function.\n *\n * @public\n */\nexport type ReturnFetchDefaultOptions = {\n  /**\n   * `fetch` function to be used in `returnFetch` function.\n   * If not provided, `fetch` function in global scope will be used.\n   * Any fetch implementation can be used, such as `node-fetch`, `cross-fetch`, `isomorphic-fetch`, etc.\n   *\n   * a `fetch` function created by `returnFetch` also can be used here.\n   *\n   * @public\n   */\n  fetch?: ReturnType<ReturnFetch>;\n  /**\n   * Base URL of fetch. It will be used when the first argument of fetch is relative URL.\n   *\n   * @public\n   */\n  baseUrl?: string | URL;\n  /**\n   * Default headers of fetch. It will be used when the second argument of fetch does not have `headers` property.\n   * If it is provided and `headers` also provided when calling a `fetch`, headers will be merged.\n   * Priority of headers is `requestInit.headers` > `defaultOptions.headers`. Duplicated headers will be overwritten.\n   *\n   * @public\n   */\n  headers?: HeadersInit;\n  interceptors?: {\n    /**\n     * Request interceptor. It will be called before request.\n     *\n     * @param requestArgs Arguments of fetch function.\n     * @param fetch the `fetch` you provided at {@link ReturnFetchDefaultOptions['fetch']}\n     *\n     * @public\n     */\n    request?: (\n      requestArgs: FetchArgs,\n    ) => Promise<FetchArgs>;\n    /**\n     * Response interceptor. It will be called after response.\n     *\n     * @param response Response object received from fetch function.\n     * @param requestArgs Arguments of fetch function.\n     * @param fetch the `fetch` you provided at {@link ReturnFetchDefaultOptions['fetch']}\n     *\n     * @public\n     */\n    response?: (\n      response: Response,\n      requestArgs: FetchArgs,\n    ) => Promise<Response>;\n  };\n};\n\nconst applyDefaultOptions = (\n  [input, requestInit]: FetchArgs,\n  defaultOptions?: ReturnFetchDefaultOptions,\n): FetchArgs => {\n  const headers = new Headers(defaultOptions?.headers);\n  new Headers(requestInit?.headers).forEach((value, key) => {\n    headers.set(key, value);\n  });\n\n  let inputToReturn: FetchArgs[0] = input;\n  if (defaultOptions?.baseUrl) {\n    inputToReturn = new URL(input, defaultOptions.baseUrl);\n  }\n\n  return [\n    inputToReturn,\n    {\n      ...requestInit,\n      headers,\n    },\n  ];\n};\n\n// To handle Request object we need to read body as ArrayBuffer.\n// If you have a better way, please let me know.\nconst mergeRequestObjectWithRequestInit = (\n  request: Request,\n  requestInit?: RequestInit,\n): Promise<RequestInit> => {\n  const mergedRequest = new Request(request, requestInit);\n  return new Response(mergedRequest.body).arrayBuffer().then((body) => ({\n    method: mergedRequest.method,\n    headers: mergedRequest.headers,\n    body: body,\n    referrer: mergedRequest.referrer,\n    referrerPolicy: mergedRequest.referrerPolicy,\n    mode: mergedRequest.mode,\n    credentials: mergedRequest.credentials,\n    cache: mergedRequest.cache,\n    redirect: mergedRequest.redirect,\n    integrity: mergedRequest.integrity,\n    keepalive: mergedRequest.keepalive,\n    signal: mergedRequest.signal,\n    window: requestInit?.window,\n  }));\n};\n\nconst normalizeArgs = async (\n  ...args: Parameters<typeof fetch>\n): Promise<FetchArgs> => {\n  let input: string | URL;\n  let requestInit: RequestInit | undefined;\n  if (args[0] instanceof Request) {\n    input = args[0].url;\n    requestInit = await mergeRequestObjectWithRequestInit(args[0], args[1]);\n  } else {\n    input = args[0];\n    requestInit = args[1];\n  }\n\n  return [input, requestInit];\n};\n\nconst returnFetch =\n  (defaultOptions?: ReturnFetchDefaultOptions) =>{\n    let newDefaultOptions = {...defaultOptions}\n    return {\n      setDefaultHeaders: (headers: HeadersInit | undefined)=>{\n        newDefaultOptions.headers = headers;\n      },\n      invoke: async (...args: Parameters<typeof fetch>): Promise<Response> => {\n        const defaultOptionAppliedArgs = applyDefaultOptions(\n          await normalizeArgs(...args),\n          defaultOptions,\n        );\n    \n        // apply request interceptor\n        const fetchProvided = defaultOptions?.fetch?.invoke || fetch;\n        let requestInterceptorAppliedArgs: FetchArgs;\n        if (defaultOptions?.interceptors?.request) {\n          requestInterceptorAppliedArgs =\n            await defaultOptions?.interceptors?.request?.(\n              defaultOptionAppliedArgs,\n            );\n        } else {\n          requestInterceptorAppliedArgs = defaultOptionAppliedArgs;\n        }\n    \n        // ajax call\n        const response = await fetchProvided(...requestInterceptorAppliedArgs);\n    \n        // apply response interceptor\n        return (\n          defaultOptions?.interceptors?.response?.(\n            response,\n            requestInterceptorAppliedArgs,\n          ) || response\n        );\n      }\n    }\n  }\n\nexport default returnFetch;\n"],"names":["returnFetch","defaultOptions","newDefaultOptions","_extends","setDefaultHeaders","headers","invoke","async","args","_defaultOptions$fetch","_defaultOptions$inter","_defaultOptions$inter3","defaultOptionAppliedArgs","applyDefaultOptions","input","requestInit","Headers","forEach","value","key","set","inputToReturn","baseUrl","URL","Request","url","mergeRequestObjectWithRequestInit","request","mergedRequest","Response","body","arrayBuffer","then","method","referrer","referrerPolicy","mode","credentials","cache","redirect","integrity","keepalive","signal","window","normalizeArgs","fetchProvided","fetch","requestInterceptorAppliedArgs","_defaultOptions$inter2","interceptors","response"],"mappings":"oOAmFA,MA+DMA,EACHC,IACC,IAAIC,EAAiBC,EAAOF,CAAAA,EAAAA,GAC5B,MAAO,CACLG,kBAAoBC,IAClBH,EAAkBG,QAAUA,CAAAA,EAE9BC,OAAQC,SAAUC,KAAqDC,IAAAA,EAAAC,EAAAC,EACrE,MAAMC,EAvEcC,GACzBC,EAAOC,GACRd,KAEA,MAAMI,EAAU,IAAIW,QAAsB,MAAdf,OAAc,EAAdA,EAAgBI,SAC5C,IAAIW,QAAmB,MAAXD,OAAW,EAAXA,EAAaV,SAASY,QAAQ,CAACC,EAAOC,KAChDd,EAAQe,IAAID,EAAKD,KAGnB,IAAIG,EAA8BP,EAKlC,OAJkB,MAAdb,GAAAA,EAAgBqB,UAClBD,EAAgB,IAAIE,IAAIT,EAAOb,EAAeqB,UAGzC,CACLD,EAAalB,EAAA,CAAA,EAERY,EAAW,CACdV,YAAO,EAqD4BQ,MAxBnBN,UACjBC,KAEH,IAAIM,EACAC,EASJ,OARIP,EAAK,aAAcgB,SACrBV,EAAQN,EAAK,GAAGiB,IAChBV,OA7BsCW,EACxCC,EACAZ,KAEA,MAAMa,EAAgB,IAAIJ,QAAQG,EAASZ,GAC3C,OAAW,IAAAc,SAASD,EAAcE,MAAMC,cAAcC,KAAMF,IAAI,CAC9DG,OAAQL,EAAcK,OACtB5B,QAASuB,EAAcvB,QACvByB,KAAMA,EACNI,SAAUN,EAAcM,SACxBC,eAAgBP,EAAcO,eAC9BC,KAAMR,EAAcQ,KACpBC,YAAaT,EAAcS,YAC3BC,MAAOV,EAAcU,MACrBC,SAAUX,EAAcW,SACxBC,UAAWZ,EAAcY,UACzBC,UAAWb,EAAca,UACzBC,OAAQd,EAAcc,OACtBC,OAAQ5B,MAAAA,OAAAA,EAAAA,EAAa4B,SACrB,EAUoBjB,CAAkClB,EAAK,GAAIA,EAAK,MAEpEM,EAAQN,EAAK,GACbO,EAAcP,EAAK,IAGd,CAACM,EAAOC,EAAW,EAYZ6B,IAAiBpC,GACvBP,GAII4C,GAA8B,MAAd5C,GAAAQ,OAAcA,EAAdR,EAAgB6C,YAAhBrC,EAAAA,EAAuBH,SAAUwC,MACvD,IAAIC,EACuC,IAAAC,EACzCD,EADgBrC,MAAdT,GAAAS,OAAcA,EAAdT,EAAgBgD,eAAhBvC,EAA8BiB,cAEV,MAAd1B,GAA4B,OAAd+C,EAAd/C,EAAgBgD,eAAhBD,MAAAA,EAA8BrB,aAA9BqB,EAAAA,EAA8BrB,QAClCf,IAG4BA,EAIlC,MAAMsC,QAAiBL,KAAiBE,GAGxC,OACgBpC,MAAdV,GAAAU,OAAcA,EAAdV,EAAgBgD,eAAhBtC,MAAAA,EAA8BuC,cAA9BvC,EAAAA,EAA8BuC,SAC5BA,EACAH,KACGG"}